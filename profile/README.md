# 얼로너즈(Alonerz)

얼로너즈는 다양한 분야의 사람들과 함께 밥을 먹으며, 전문 분야의 지식과 통찰을 얻기 위한 모임 플랫폼 서비스입니다.

> 2017년 트렌드 키워드인 `aloner`는 혼자라는 뜻의 `alone`과 명사형 접미사 `er`가 혼합된 '혼자인 삶을 즐기는 사람들'이라는 의미의 단어입니다. 저희 서비스는 사람들 간의 생산적인 모임을 제공하기 위해 '우리'를 뜻하는 `us`를 `z`로 표기하여 Alonerz로 명명하였습니다.

# Contributors

|                  백엔드                   |                프론트엔드                |                   디자이너                   |
| :---------------------------------------: | :--------------------------------------: | :------------------------------------------: |
|    [최원영](https://github.com/choewy)    |  [김형중](https://github.com/fomula91)   |    [김령은](https://behance.net/ella_re)     |
| [김지웅](https://github.com/KimJiWoong02) | [김민우](https://github.com/purplephone) | [장민선](https://blog.naver.com/alstjs11120) |

# Architecture

![alonerz-1 drawio](https://user-images.githubusercontent.com/70950533/169298516-23e6d109-606f-411a-bfef-8f0727cbf4d1.png)

# Technical Stacks

- 공통 : `Kakao Map API`, `Kakao Login API`, `JWT OAuth`, `Socket.io`, `TypeScript`
- 프론트엔드 : `React`, `Redux`, `Styled-component`
- 백엔드 : `NestJS`, `TypeORM`, `MySQL`, `Passport`, `Swagger`

# Current

- 현재 프로젝트 진행 상황

# After

- 앞으로 구현할 내용 및 방향

# Trouble Shootings

## 기획 및 설계

### 사용자 블랙리스트 또는 신고 시스템 검토

- 서비스의 로직을 설계할 때, 다양한 상황을 미리 예상하여, 예상치 못한 오류에 대해서 예외처리를 해나가고자 하였습니다.
- 더 나아가, 저희 서비스 특성상 이용자에 대한 특수한 상황에 대한 예외 처리까지 생각해보았습니다.
- 서비스에 부정적인 이용자를 블랙리스트에 추가하여 서비스 이용을 제한하거나, 다른 사람들에게 부정적인 행동을 하는 이용자를 신고할 수 있는 시스템이 필요할 것으로 생각되었습니다.
- 그러던 중, 다른 사용자가 아무 이유 없이 누군가를 신고하는 경우, 피신고자를 블랙리스트에서 회생시켜야 하는 로직을 생각해내야 했습니다.
- 서비스 운영 시, 운영자(관리자)가 필요할 것으로 생각하여 관리자 페이지를 구현하려고 하였으나, 잦은 기획 변경 탓에 MVC 구현 시간도 빠듯하다고 생각하여 이용자 간 팔로우/차단 시스템을 도입하기로 하였습니다.

## 프론트엔드

### Redux Store 상태값 최신화 이슈

- 파티 그룹 조회 목록을 렌더링할 때, 데이터를 서버로부터 전달받은 후 Redux에 저장하였습니다.
- 이때, Redux Middleware에서 서버와 통신을 하고, Redux 내에서 데이터를 가공 후 저장하여 렌더링하도록 하였습니다.
- 이와 같은 방식은 사용자가 최초 접속 시 가장 최신 데이터를 받아온 상태이므로 큰 문제는 없는 것으로 보였으나, 뒤로가기, 다른 페이지로부터의 유입 시에는 최신 데이터로 업데이트되지 않는 문제가 발생하였습니다.
- 즉, Redux에 저장되어 있는 정보로만 렌더링하는 경우, 사용자는 최신 데이터를 확인할 수 없고, Redux에 최신 데이터를 저장하기 위해 매 행동마다 Action을 발생시킬 수 있을 것으로 생각하였습니다.
- 그러나, 이와 같이 수정하는 경우에는 매 행동마다 Redux Action을 발생시키므로 Redux의 성능상 이점을 누릴 수 없다고 판단하였습니다.
- 따라서, 사용자의 로그인 상태, 인증 상태 등의 공통된 데이터만을 Redux에 저장하도록 하였고, 특정 페이지에서만 필요한 데이터는 해당 페이지에서 axios로 요청하여 state로 상태를 관리하도록 변경하였습니다.

### 게시물 정보 생성 및 수정 페이지 리렌더링 이슈

- 게시물 정보를 생성하고, 수정하는 페이지를 하나의 컴포넌트로 구성하였습니다.
- 게시물을 생성하는 경우에는 input 태그에 임시 value를 입력하도록 하였고, 수정하는 경우에는 서버에서 데이터를 가져온 후 렌더링하도록 하였습니다.
- 게시물을 생성하는 경우에는 rerendering이 발생하지 않았지만, 게시물을 수정하는 경우에는 rerendering이 발생하는 문제가 발생하였습니다.
- 이는 서로 다른 두 개의 로직(생성과 수정)이 하나의 컴포넌트 안에서 동작하기 때문에 발생하는 것을 원인으로 보았으며, 코드 가독성 및 재사용성 면에서도 효율적이지 못한 방법이라고 생각하였습니다.
- 따라서, 컴포넌트를 상위 컴포넌트와 하위 컴포넌트로 나눈 후, 서버로부터 전달받은 데이터를 하위 컴포넌트에 전달하여 rerendering 시키도록 개선하였습니다.

## 백엔드

### 프레임워크 선정 이슈(1) - Express VS NestJS

- 개발 초기 단계에서 Express와 NestJS를 두고 많은 고민을 하였습니다.
- 지금까지는 주로 Express를 사용하여 개발을 해오다보니, 의존성 주입과 역전, 제어의 역전, IoC 컨테이너 등의 동작 원리를 명확히 파악하지 않은 상태로 단지 NestJS의 사용 방법(how to use)만 터득하여 서비스를 개발하는게 맞는지에 대해 고민하였습니다.
- 그 결과, Express를 사용하여 개발 후 리팩토링 과정에서 NestJS의 구조를 적용하고, 의존성 주입과 역전, 제어의 역전의 필요성을 느껴보고자 하였습니다.

## 프레임워크 선정 이슈(2) - TypeORM cli로 생성한 프로젝트 구조 개선

- `TypeORM(0.3.x)`의 cli로 프로젝트를 초기화했을 당시, Express에 Route를 등록하는 코드는 다음과 같이 구성되어 있었습니다.

```ts
// routes.ts
const Routes = [
  {
    method: 'get',
    route: '/',
    controller: AppController,
    action: 'swagger',
  },
];

export const routes = (() => {
  const router = Router();
  Routes.forEach((route) => {
    /* Routes에 담긴 컨트롤러를 router에 미들웨어로 등록합니다. */
  });
  return router;
})();
```

- 기능이 추가됨에 따라 Route를 `Routes` 배열에 넣어주어야 했으며, Controller의 함수명을 변경할 때마다 `Routes`의 `action`을 직접 수정해주어야 하는 점이 매우 불편하게 느껴졌습니다.
- 뿐만 아니라, 미들웨어를 추가하려는 경우 `Routes` 요소에 미들웨어를 추가해주는 방식을 검토하였는데, 이를 구현하는 과정에서 미들웨어 존재여부를 파악하기 위한 분기 처리, 미들웨어가 여러개 존재하는 경우의 로직을 구현하는 과정에서 다른 팀원이 이해하기 어려울 정도로 코드의 가독성이 떨어지는 문제가 발생되었습니다.
- 따라서, NestJS의 Decorator(@Controller, @Get)를 직접 적용시켜보고자 하였습니다.
- @Controller, @Middleware, @Get, @Post, @Patch, @Put, @Delete 데코레이터 함수를 구현하여, 코드의 가독성과 개발 효율성을 높일 수 있었습니다.

### 프레임워크 선정 이슈(3) - providers의 필요성 확인

- 앞의 내용과 같이 컨트롤러, 미들웨어까지는 데코레이터를 통해 비교적 편리하게 개발을 할 수 있었습니다.
- 그러나, Service 로직을 컨트롤러로 불러오는 과정에서 또 다른 문제와 직면하게 되었습니다.
- 지금까지의 컨트롤러 클래스는 인스턴스로 생성하기 전까지는 추상화된 클래스이므로, 아래 코드가 실행되기 전까지는 실체가 없다는 사실을 알게 되었습니다.

```ts
// app.ts
providers.controllers.forEach((Controller) => {
  app.use(new Controller()['router']);
});
```

- 그렇기 때문에 service를 클래스 내부의 인스턴스로 호출하여 사용하려고 하면, service가 undefined로 나타나는 문제가 발생합니다. 이를 해결하기 위해서는 NestJS의 `@Injectable` 데코레이터를 구현해야하고, 의존성을 주입시켜줄 `@Module` 데코레이터까지 구현하여 provider를 주입시켜야 한다는 사실을 알게되었습니다.
- 여기까지 구현하면 프로젝트를 진행하면서 NestJS의 동작 원리까지 얻고자 했던 초기 목적이, NestJS의 동작 원리를 얻기 위해 프로젝트를 진행하는 것으로 역전된다고 생각하여, NestJS로 프레임워크를 변경하게 되었습니다.
