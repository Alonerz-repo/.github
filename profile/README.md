# 얼로너즈(Alonerz)

얼로너즈는 다양한 분야의 사람들과 함께 밥을 먹으며, 전문 분야의 지식과 통찰을 얻기 위한 모임 플랫폼 서비스입니다.

> 2017년 트렌드 키워드인 `aloner`는 혼자라는 뜻의 `alone`과 명사형 접미사 `er`가 혼합된 '혼자인 삶을 즐기는 사람들'이라는 의미의 단어입니다. 저희 서비스는 사람들 간의 생산적인 모임을 제공하기 위해 '우리'를 뜻하는 `us`를 `z`로 표기하여 Alonerz로 명명하였습니다.

# Contributors

|                  백엔드                   |                프론트엔드                |                   디자이너                   |
| :---------------------------------------: | :--------------------------------------: | :------------------------------------------: |
|    [최원영](https://github.com/choewy)    |  [김형중](https://github.com/fomula91)   |    [김령은](https://behance.net/ella_re)     |
| [김지웅](https://github.com/KimJiWoong02) | [김민우](https://github.com/purplephone) | [장민선](https://blog.naver.com/alstjs11120) |

# Architecture

![alonerz-1 drawio](https://user-images.githubusercontent.com/70950533/169298516-23e6d109-606f-411a-bfef-8f0727cbf4d1.png)

# Technical Stacks

- 공통 : `Kakao Map API`, `Kakao Login API`, `JWT OAuth`, `Socket.io`, `TypeScript`
- 프론트엔드 : `React`, `Redux`, `Styled-component`
- 백엔드 : `NestJS`, `TypeORM`, `MySQL`, `Passport`, `Swagger`

# Current

## 카카오 로그인 API를 사용한 로그인 / 회원가입 기능

저희 서비스를 통해 실제로 생산적인 모임이 성사되어야 하므로 최소한의 본인인증이 필요합니다. 따라서, 지금 당장 적용할 수 있는 인증 방식, 대중적으로 사용하고 있는 플랫폼 서비스인 카카오 로그인 API를 사용하여 최소한의 신원 정보를 인증받을 수 있도록 하였습니다.

## 회원 정보 수정

다양한 분야의 사람들이 실제 모임을 통해 소통하여야 하므로, 회원 정보를 닉네임, 직종, 직업, 연차, 한 줄 소개로 구성하도록 하였습니다.

## 팔로우 및 차단 기능

블랙리스트, 신고 시스템을 필요성을 느낀 후 이를 적용하고자 하였으나, 시간적으로 관리자 측면에서의 추가 기능을 구현하기 빠듯할 것으로 예상하여 사용자 간 팔로우 및 차단 기능을 통해 직접 블랙리스트를 관리할 수 있도록 하였습니다.

## 그룹 생성, 조회, 참여 및 탈퇴 기능

그룹 조회 시 현재 접속자의 위도와 경로를 기준으로 인접한 그룹만을 조회할 수 있도록 설계하였습니다. 아직 이 기능은 완벽하게 구현되지 않은 상태이며, 빠른 시일 내에 구현할 예정입니다.

## 그룹 댓글, 대댓글 기능

댓글로 그룹의 추가 정보를 공유할 수 있도록 설계하였습니다. 댓글에는 하위 댓글을 입력할 수 있으며, `댓글 더보기` 버튼을 클릭하여 하위 댓글 정보를 요청할 수 있도록 구현하였습니다.

# After

## `[FE]` KakaoMap API를 사용한 장소 검색 및 마커 처리

KakaoMap API를 사용하여 지도를 렌더링 할 수 있도록 구현된 상태이나, 장소 검색, 마커 표시 등이 미흡한 상태입니다. 따라서, 이를 최우선으로 보완할 예정입니다.

## `[FE]` 무한 스크롤을 적용한 렌더링 방식 적용

그룹 목록, 댓글, 팔로잉/팔로워 목록, 차단 목록 등 한꺼번에 많은 데이터가 들어오는 경우 over-fatching 현상이 발생할 수 있다고 생각하여, 무한 스크롤 렌더링 방식을 적용할 예정입니다.

## `[FE]` 1:1 DM 기능 및 알림 기능

이전 모임을 통해 만났던 사람들 간의 안부를 묻거나, 그룹 방장에게 직접 DM을 보내는 등의 기능이 필요할 것으로 판단하여 1:1 DM 기능을 MVP에 추가하였습니다. 현재 서버 측은 80% 정도 구현된 상태이며, 프론트 측은 앞의 기능을 개발한 후에 진행할 예정입니다.

## `[FE]` 프로필의 캐릭터 및 스티커 편집 기능

자신을 나타낼 수 있는 방법으로는 태그, 라벨 등 여러 방법이 있겠으나, 본 프로젝트를 통해 기술적인 도전과 성능 향상을 경험하고자 캐릭터와 스티커를 정적 이미지로 배치시키는 기능을 MVP 항목에 추가하였습니다. 이들은 모두 정적 이미지로 S3에 저장되어 있으며, 이미지 렌더링 시 지연 로딩 방식(lazy-loading)을 적용하고, 이미지 크기를 조정(resize)하여 클라이언트의 성능을 개선할 예정입니다.

## `[BE]` 현재 접속자의 위도와 경도를 기준으로 인접한 그룹 목록 조회 로직 구현

현재 구현된 그룹 목록 조회 API에서는 위도와 경로를 각각 query string으로 받아올 수 있도록 하였습니다. 이를 통해 반경 3km 이내에 존재하는 그룹 정보를 조회할 수 있도록 쿼리를 수정할 예정입니다.

## `[BE]` 그룹 생성 및 참여 시 해당 사용자의 참여 그룹 정보 확인

사용자가 그룹을 생성하거나, 참여할 때 동일한 시간에 모임이 겹치지 않는지 예외처리를 해주어야 합니다. 따라서, 사용자가 그룹을 생성하거나, 참여하기 전에 해당 시간대에 참여하기로 한 다른 그룹이 있는지 파악할 수 있는 로직을 구현할 예정입니다.

# Trouble Shootings

## 기획 및 설계

### 사용자 블랙리스트 또는 신고 시스템 검토

- 서비스의 로직을 설계할 때, 다양한 상황을 미리 예상하여, 예상치 못한 오류에 대해서 예외처리를 해나가고자 하였습니다.
- 더 나아가, 저희 서비스 특성상 이용자에 대한 특수한 상황에 대한 예외 처리까지 생각해보았습니다.
- 서비스에 부정적인 이용자를 블랙리스트에 추가하여 서비스 이용을 제한하거나, 다른 사람들에게 부정적인 행동을 하는 이용자를 신고할 수 있는 시스템이 필요할 것으로 생각되었습니다.
- 그러던 중, 다른 사용자가 아무 이유 없이 누군가를 신고하는 경우, 피신고자를 블랙리스트에서 회생시켜야 하는 로직을 생각해내야 했습니다.
- 서비스 운영 시, 운영자(관리자)가 필요할 것으로 생각하여 관리자 페이지를 구현하려고 하였으나, 잦은 기획 변경 탓에 MVC 구현 시간도 빠듯하다고 생각하여 이용자 간 팔로우/차단 시스템을 도입하기로 하였습니다.

## 프론트엔드

### Redux Store 상태값 최신화 이슈

- 파티 그룹 조회 목록을 렌더링할 때, 데이터를 서버로부터 전달받은 후 Redux에 저장하였습니다.
- 이때, Redux Middleware에서 서버와 통신을 하고, Redux 내에서 데이터를 가공 후 저장하여 렌더링하도록 하였습니다.
- 이와 같은 방식은 사용자가 최초 접속 시 가장 최신 데이터를 받아온 상태이므로 큰 문제는 없는 것으로 보였으나, 뒤로가기, 다른 페이지로부터의 유입 시에는 최신 데이터로 업데이트되지 않는 문제가 발생하였습니다.
- 즉, Redux에 저장되어 있는 정보로만 렌더링하는 경우, 사용자는 최신 데이터를 확인할 수 없고, Redux에 최신 데이터를 저장하기 위해 매 행동마다 Action을 발생시킬 수 있을 것으로 생각하였습니다.
- 그러나, 이와 같이 수정하는 경우에는 매 행동마다 Redux Action을 발생시키므로 Redux의 성능상 이점을 누릴 수 없다고 판단하였습니다.
- 따라서, 사용자의 로그인 상태, 인증 상태 등의 공통된 데이터만을 Redux에 저장하도록 하였고, 특정 페이지에서만 필요한 데이터는 해당 페이지에서 axios로 요청하여 state로 상태를 관리하도록 변경하였습니다.

### 게시물 정보 생성 및 수정 페이지 리렌더링 이슈

- 게시물 정보를 생성하고, 수정하는 페이지를 하나의 컴포넌트로 구성하였습니다.
- 게시물을 생성하는 경우에는 input 태그에 임시 value를 입력하도록 하였고, 수정하는 경우에는 서버에서 데이터를 가져온 후 렌더링하도록 하였습니다.
- 게시물을 생성하는 경우에는 rerendering이 발생하지 않았지만, 게시물을 수정하는 경우에는 rerendering이 발생하는 문제가 발생하였습니다.
- 이는 서로 다른 두 개의 로직(생성과 수정)이 하나의 컴포넌트 안에서 동작하기 때문에 발생하는 것을 원인으로 보았으며, 코드 가독성 및 재사용성 면에서도 효율적이지 못한 방법이라고 생각하였습니다.
- 따라서, 컴포넌트를 상위 컴포넌트와 하위 컴포넌트로 나눈 후, 서버로부터 전달받은 데이터를 하위 컴포넌트에 전달하여 rerendering 시키도록 개선하였습니다.

## 백엔드

### 프레임워크 선정 이슈(1) - Express VS NestJS

- 개발 초기 단계에서 Express와 NestJS를 두고 많은 고민을 하였습니다.
- 지금까지는 주로 Express를 사용하여 개발을 해오다보니, 의존성 주입과 역전, 제어의 역전, IoC 컨테이너 등의 동작 원리를 명확히 파악하지 않은 상태로 단지 NestJS의 사용 방법(how to use)만 터득하여 서비스를 개발하는게 맞는지에 대해 고민하였습니다.
- 그 결과, Express를 사용하여 개발 후 리팩토링 과정에서 NestJS의 구조를 적용하고, 의존성 주입과 역전, 제어의 역전의 필요성을 느껴보고자 하였습니다.

### 프레임워크 선정 이슈(2) - TypeORM cli로 생성한 프로젝트 구조 개선

- `TypeORM(0.3.x)`의 cli로 프로젝트를 초기화했을 당시, Express에 Route를 등록하는 코드는 다음과 같이 구성되어 있었습니다.

```ts
// routes.ts
const Routes = [
  {
    method: 'get',
    route: '/',
    controller: AppController,
    action: 'swagger',
  },
];

export const routes = (() => {
  const router = Router();
  Routes.forEach((route) => {
    /* Routes에 담긴 컨트롤러를 router에 미들웨어로 등록합니다. */
  });
  return router;
})();
```

- 기능이 추가됨에 따라 Route를 `Routes` 배열에 넣어주어야 했으며, Controller의 함수명을 변경할 때마다 `Routes`의 `action`을 직접 수정해주어야 하는 점이 매우 불편하게 느껴졌습니다.
- 뿐만 아니라, 미들웨어를 추가하려는 경우 `Routes` 요소에 미들웨어를 추가해주는 방식을 검토하였는데, 이를 구현하는 과정에서 미들웨어 존재여부를 파악하기 위한 분기 처리, 미들웨어가 여러개 존재하는 경우의 로직을 구현하는 과정에서 다른 팀원이 이해하기 어려울 정도로 코드의 가독성이 떨어지는 문제가 발생되었습니다.
- 따라서, NestJS의 Decorator(@Controller, @Get)를 직접 적용시켜보고자 하였습니다.
- @Controller, @Middleware, @Get, @Post, @Patch, @Put, @Delete 데코레이터 함수를 구현하여, 코드의 가독성과 개발 효율성을 높일 수 있었습니다.

### 프레임워크 선정 이슈(3) - providers의 필요성 확인

- 앞의 내용과 같이 컨트롤러, 미들웨어까지는 데코레이터를 통해 비교적 편리하게 개발을 할 수 있었습니다.
- 그러나, Service 로직을 컨트롤러로 불러오는 과정에서 또 다른 문제와 직면하게 되었습니다.
- 지금까지의 컨트롤러 클래스는 인스턴스로 생성하기 전까지는 추상화된 클래스이므로, 아래 코드가 실행되기 전까지는 실체가 없다는 사실을 알게 되었습니다.

```ts
// app.ts
providers.controllers.forEach((Controller) => {
  app.use(new Controller()['router']);
});
```

- 그렇기 때문에 service를 클래스 내부의 인스턴스로 호출하여 사용하려고 하면, service가 undefined로 나타나는 문제가 발생합니다. 이를 해결하기 위해서는 NestJS의 `@Injectable` 데코레이터를 구현해야하고, 의존성을 주입시켜줄 `@Module` 데코레이터까지 구현하여 provider를 주입시켜야 한다는 사실을 알게되었습니다.
- 여기까지 구현하면 프로젝트를 진행하면서 NestJS의 동작 원리까지 얻고자 했던 초기 목적이, NestJS의 동작 원리를 얻기 위해 프로젝트를 진행하는 것으로 역전된다고 생각하여, NestJS로 프레임워크를 변경하게 되었습니다.
