# 얼로너즈(Alonerz)

얼로너즈는 다양한 분야의 사람들과 함께 밥을 먹으며, 전문 분야의 지식과 통찰을 얻기 위한 모임 플랫폼 서비스입니다.

> 2017년 트렌드 키워드인 `aloner`는 혼자라는 뜻의 `alone`과 명사형 접미사 `er`가 혼합된 '혼자인 삶을 즐기는 사람들'이라는 의미의 단어입니다. 저희 서비스는 사람들 간의 생산적인 모임을 제공하기 위해 '우리'를 뜻하는 `us`를 `z`로 표기하여 Alonerz로 명명하였습니다.

# Contributors

|                  백엔드                   |                프론트엔드                |                   디자이너                   |
| :---------------------------------------: | :--------------------------------------: | :------------------------------------------: |
|    [최원영](https://github.com/choewy)    |  [김형중](https://github.com/fomula91)   |    [김령은](https://behance.net/ella_re)     |
| [김지웅](https://github.com/KimJiWoong02) | [김민우](https://github.com/purplephone) | [장민선](https://blog.naver.com/alstjs11120) |

# Architecture

![alonerz-1 drawio](https://user-images.githubusercontent.com/70950533/169298516-23e6d109-606f-411a-bfef-8f0727cbf4d1.png)

# Technical Stacks

- 공통 : `Kakao Map API`, `Kakao Login API`, `JWT OAuth`, `Socket.io`, `TypeScript`
- 프론트엔드 : `React`, `Redux`, `Styled-component`
- 백엔드 : `NestJS`, `TypeORM`, `MySQL`, `Passport`, `Swagger`

# Trouble Shootings

## 기획 및 설계

### 사용자 블랙리스트 또는 신고 시스템 검토

- 서비스의 로직을 설계할 때, 다양한 상황을 미리 예상하여, 예상치 못한 오류에 대해서 예외처리를 해나가고자 하였습니다.
- 더 나아가, 저희 서비스 특성상 이용자에 대한 특수한 상황에 대한 예외 처리까지 생각해보았습니다.
- 서비스에 부정적인 이용자를 블랙리스트에 추가하여 서비스 이용을 제한하거나, 다른 사람들에게 부정적인 행동을 하는 이용자를 신고할 수 있는 시스템이 필요할 것으로 생각되었습니다.
- 그러던 중, 다른 사용자가 아무 이유 없이 누군가를 신고하는 경우, 피신고자를 블랙리스트에서 회생시켜야 하는 로직을 생각해내야 했습니다.
- 서비스 운영 시, 운영자(관리자)가 필요할 것으로 생각하여 관리자 페이지를 구현하려고 하였으나, 잦은 기획 변경 탓에 MVC 구현 시간도 빠듯하다고 생각하여 이용자 간 팔로우/차단 시스템을 도입하기로 하였습니다.

## 프론트엔드

### Redux Store 상태값 최신화 이슈

- 서버로부터 전달받은 데이터를 Redux store에 저장하여 상태값을 관리하였는데, 상태값이 최신화되지 않는 이슈가 발생하였습니다.
- `이러한 이슈가 발생한 원인은 ~ 때문이었습니다.`
- 따라서, Redux store를 사용하지 않고, 특정 페이지에 접속할 때 해당 페이지에 필요한 데이터만 받아오도록 로직을 수정하여 해결하였습니다.

### 상태값 업데이트 실패 이슈

- 사용자 편의 측면에서 하나의 페이지 데이터를 조회하고, 수정할 수 있도록 하나의 컴포넌트에서 렌더링하도록 구현하였습니다.
- 렌더링 과정에서 오류를 발생시키지 않도록 하기 위하여 상태값을 초기화하였는데, 서버로부터 전달받은 데이터로 업데이트되지 않는 이슈가 발생하였습니다.
- `이러한 이슈가 발생한 원인은 ~이었습니다.`
- 따라서, Custom Hook을 사용하여 서버로부터 데이터를 받아오는 역할과 데이터를 렌더링하는 컴포넌트를 분리하였습니다.
- 각각 역할에 따라 서로 다른 파일에 코드가 존재하므로, Pull Request 시 충돌 발생이 줄어들었고, 코드의 가독성이 높아졌음을 알 수 있었습니다.
- 또한, 서버로 데이터를 받아오는 부분을 Custom Hook으로 분리하였기 때문에 다른 파일에서 동일한 기능을 사용해야 하는 경우 해당 Custom Hook만 import하면 되므로 코드의 재사용성이 증가하였음을 알 수 있었습니다.

### 댓글 관련 이슈

- 댓글의 CRUD는 쉽게 구현할 수 있었으나, 상위 댓글과 하위 댓글을 렌더링할 때 API가 별도로 존재하여 한 번에 호출하는 것에 어려움을 느꼈습니다.
- 하위 댓글이 상위 댓글에 의존적이다보니, 하나의 컴포넌트에서 두 개의 API를 모두 호출하는 경우 404 오류가 발생하는 이슈가 발생하였습니다.
- 따라서, 상위 댓글과 하위 댓글을 컴포넌트로 분리시켜야 할 필요성을 느꼈습니다. 또한, 이를 구현하는 과정에서 만약, 컴포넌트를 분리한다면, 이미 생성된 상위 댓글 컴포넌트에 하위 댓글 컴포넌트를 끼워넣을 수 있는지에 대해 의문이 들었습니다.
- 고심 끝에 이 방법을 테스트해보았고, 하위 댓글이 1개 이상인 경우, '댓글 더보기' 버튼을 클릭할 때 하위 댓글을 조회하는 API를 요청하여 렌더링하는 방식으로 구현하였습니다.

## 백엔드
